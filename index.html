<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Autospiel mit stufenlosem Lenkrad und Dunkelmodus</title>
  <style>
    /* Stil f√ºr das SVG und das Auto */
    #road {
      width: 560px;
      height: 450px;
      background-color: #eee; /* Hellerer Hintergrund f√ºr besseren Kontrast */
      position: relative;
      margin: 0 auto;
      overflow: hidden;
      border: 1px solid #ccc; /* Optional: Rahmen um die Stra√üe */
    }

    #car {
      width: 40px;
      height: 80px;
      background: red;
      border-radius: 20px 20px 0 0; /* Etwas eckiger */
      position: absolute;
      bottom: 10px; /* Etwas h√∂her starten */
      left: calc(50% - 20px); /* Angepasst an Breite */
      transition: left 0.1s linear; /* Schnellere Reaktion auf Lenkung */
      z-index: 10; /* Auto √ºber Hindernissen und Fragmenten */
      box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Kleiner Schatten */
    }

    /* Stil f√ºr die Hindernisse */
    .obstacle {
      fill: green;
      position: absolute; /* Wird eigentlich nicht gebraucht f√ºr SVG-Elemente */
      animation: obstacleAnimation 6s linear infinite; /* Etwas schnellere Hindernisse */
      transition: fill 0.2s ease; /* Sanfter Farbwechsel */
      /* Wichtig: Damit getBoundingClientRect korrekte Werte liefert, auch wenn Transform aktiv ist */
      transform-origin: center center;
      will-change: transform; /* Performance-Hinweis */
    }

    /* Animation f√ºr Hindernisse */
    @keyframes obstacleAnimation {
      0% { transform: translateY(-150px); } /* Start weiter oben */
      100% { transform: translateY(650px); } /* Ziel weiter unten */
    }

    /* Unterschiedliche Startverz√∂gerungen (optional, macht es zuf√§lliger) */
    .obstacle.o1 { animation-delay: 0s; }
    .obstacle.o2 { animation-delay: -2s; }
    .obstacle.o3 { animation-delay: -4s; }
    .obstacle.o4 { animation-delay: -1s; }
    .obstacle.o5 { animation-delay: -3s; }
    .obstacle.o6 { animation-delay: -5s; }


    /* Stil f√ºr das Lenkrad */
    #steering-wheel-container { /* Umbenannt f√ºr Klarheit */
      position: relative;
      width: 300px; /* Angepasste Gr√∂√üe */
      height: 150px; /* Halbkreis */
      margin: 20px auto 0; /* Positionierung angepasst */
      overflow: hidden;
      cursor: pointer;
      border: 2px solid #555; /* Rahmen f√ºr Klickbereich */
      border-radius: 150px 150px 0 0; /* Oben abgerundet */
      background: #f0f0f0; /* Heller Hintergrund */
    }

    #steering-wheel-svg { /* SVG-Element selbst */
        width: 100%;
        height: 100%;
        display: block;
    }

    #steering-wheel-svg path {
      fill: none; /* Innen leer */
      stroke: black; /* Schwarzer Ring */
      stroke-width: 10; /* Dicke des Rings */
    }

    #steering-wheel-svg .wheel-line { /* Gemeinsame Klasse f√ºr Linien */
      stroke: red;
      stroke-width: 5;
      transform-origin: 150px 150px; /* Drehpunkt unten Mitte des Containers */
      transition: transform 0.1s linear; /* Sanftere Drehung */
    }

    /* Stil f√ºr den Dunkelmodus-Schalter */
    #dark-mode-toggle {
      position: relative;
      width: 40px;
      height: 40px;
      background-color: #ffd700; /* Goldgelb */
      border-radius: 50%;
      cursor: pointer;
      margin: 20px auto; /* Unter dem Lenkrad zentriert */
      z-index: 2;
      border: 2px solid #aaa;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
       display: flex; /* Zentriert Icon */
       align-items: center;
       justify-content: center;
       font-size: 20px; /* F√ºr Icon */
    }
     /* Anfangs Sonnen-Icon */
     #dark-mode-toggle::before {
        content: '‚òÄÔ∏è';
     }


    /* Neue Klasse f√ºr √ºberfahrene Hindernisse */
    .hit {
      fill: gray !important; /* Wichtig, um Fill zu √ºberschreiben, auch im Dark Mode */
    }

    /* NEU: Stil f√ºr Explosionsfragmente */
    .fragment {
        pointer-events: none; /* Fragmente sollen nicht klickbar sein oder Kollision ausl√∂sen */
        will-change: transform, opacity; /* Performance-Hinweis */
    }

    .fragment-exploding {
        animation: explode 0.6s ease-out forwards; /* Dauer der Explosion */
    }

    @keyframes explode {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        /* CSS-Variablen werden per JS gesetzt */
        transform: translate(var(--tx, 0), var(--ty, 0)) scale(0.3);
        opacity: 0;
      }
    }


    /* Dunkelmodus-Stile */
    body.dark-mode {
      background-color: #1a1a1a; /* Dunkelgrau statt rein schwarz */
      color: #e0e0e0; /* Helles Grau f√ºr Text */
    }

    body.dark-mode #road {
      background-color: #333; /* Dunklerer Stra√üenhintergrund */
       border: 1px solid #555;
    }

    body.dark-mode .obstacle {
      fill: #006400; /* Dunkleres Gr√ºn */
    }

    body.dark-mode #car {
      background-color: #b22222; /* Firebrick statt darkred */
      box-shadow: 0 4px 8px rgba(255,255,255,0.2); /* Hellerer Schatten */
    }

     body.dark-mode #steering-wheel-container {
        background: #2c2c2c;
        border: 2px solid #777;
     }

    body.dark-mode #steering-wheel-svg path {
      stroke: #888; /* Dunklerer Ring */
    }

    body.dark-mode #steering-wheel-svg .wheel-line {
      stroke: #dc143c; /* Crimson statt darkred */
    }

    /* .hit bleibt grau, keine extra Regel n√∂tig dank !important */

    body.dark-mode #dark-mode-toggle {
        background-color: #4a4a4a; /* Dunkler Hintergrund */
        border: 2px solid #888;
        box-shadow: 0 2px 4px rgba(255,255,255,0.1);
    }
     /* Mond-Icon im Dark Mode */
    body.dark-mode #dark-mode-toggle::before {
        content: 'üåô';
    }

  </style>
</head>
<body>
  <div id="road">
    <svg id="game-svg" width="100%" height="100%">
      <!-- Hindernisse als Kreise - Mehr davon! -->
      <circle class="obstacle o1" cx="80" cy="-50" r="25" />
      <circle class="obstacle o2" cx="200" cy="-150" r="35" />
      <circle class="obstacle o3" cx="350" cy="-80" r="30" />
      <circle class="obstacle o4" cx="480" cy="-250" r="40" />
      <circle class="obstacle o5" cx="150" cy="-350" r="30" />
      <circle class="obstacle o6" cx="400" cy="-450" r="28" />
      <circle class="obstacle o1" cx="280" cy="-550" r="32" />
      <circle class="obstacle o2" cx="50"  cy="-650" r="22" />
      <circle class="obstacle o3" cx="450" cy="-720" r="38" />
       <!-- Man kann hier leicht weitere hinzuf√ºgen -->
    </svg>
    <!-- Das Auto -->
    <div id="car"></div>
  </div>

  <!-- Lenkrad -->
  <div id="steering-wheel-container">
    <svg id="steering-wheel-svg" viewBox="0 0 300 150"> <!-- viewBox f√ºr Skalierbarkeit -->
      <!-- Halbkreis -->
      <path d="M 20 145 A 130 130 0 0 1 280 145" fill="none" stroke="black" stroke-width="10" />
      <!-- Rote Linie (als Gruppe f√ºr gemeinsame Drehung) -->
      <g id="wheel-lines">
          <line class="wheel-line" x1="150" y1="150" x2="150" y2="50" />
          <!-- Optional: Speichen hinzuf√ºgen -->
          <line class="wheel-line" x1="150" y1="150" x2="50" y2="100" />
           <line class="wheel-line" x1="150" y1="150" x2="250" y2="100" />
      </g>
    </svg>
  </div>

  <!-- Dunkelmodus-Schalter -->
  <div id="dark-mode-toggle"></div>

  <script>
    const car = document.getElementById('car');
    const road = document.getElementById('road');
    const steeringWheelContainer = document.getElementById('steering-wheel-container');
    const wheelLines = document.getElementById('wheel-lines'); // Gruppe der Linien
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const gameSvg = document.getElementById('game-svg'); // SVG-Container f√ºr Fragmente

    let isDragging = false;
    let currentAngle = 0; // Aktueller Lenkwinkel

    // --- Lenkrad-Logik ---

    function getAngleFromEvent(event) {
        const rect = steeringWheelContainer.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height; // Drehpunkt unten mittig
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;

        // Winkel berechnen (atan2 gibt Winkel im Bogenma√ü zur√ºck)
        let angle = Math.atan2(clientY - centerY, clientX - centerX);

        // Winkel auf den oberen Halbkreis beschr√§nken (-PI bis 0) und in Grad umwandeln
        // und dann auf einen Bereich von ca. -90 bis +90 Grad mappen
        angle = angle * (180 / Math.PI); // In Grad

        // Anpassen, sodass 0 Grad nach oben zeigt (-90 Grad von atan2)
        angle += 90;

        // Begrenzen auf ca. +/- 80 Grad (etwas weniger als volle 90 f√ºr besseres Gef√ºhl)
        angle = Math.max(-80, Math.min(80, angle));
        return angle;
    }

    function updateSteeringWheel(angle) {
        currentAngle = angle;
        wheelLines.style.transform = `rotate(${angle}deg)`; // Dreht die ganze Gruppe
    }

    function moveCar(angle) {
        const roadWidth = road.offsetWidth;
        const carWidth = car.offsetWidth;
        // Maximaler Ausschlag des Autos (z.B. 40% der Stra√üenbreite zu jeder Seite)
        const maxCarOffset = (roadWidth - carWidth) * 0.45;

        // Mappt den Winkel (-80 bis +80) auf den Offset (-maxCarOffset bis +maxCarOffset)
        const carOffset = (angle / 80) * maxCarOffset;

        // Berechnet die linke Position des Autos relativ zur Stra√üenmitte
        const carLeft = (roadWidth / 2) - (carWidth / 2) + carOffset;

        // Begrenzen, damit das Auto auf der Stra√üe bleibt
        const minLeft = 0;
        const maxLeft = roadWidth - carWidth;
        car.style.left = `${Math.max(minLeft, Math.min(maxLeft, carLeft))}px`;
    }


    function handleSteeringStart(event) {
        isDragging = true;
        const angle = getAngleFromEvent(event);
        updateSteeringWheel(angle);
        moveCar(angle);
        steeringWheelContainer.style.cursor = 'grabbing';
    }

    function handleSteeringMove(event) {
        if (isDragging) {
            // Verhindert Textauswahl beim Ziehen
            event.preventDefault();
            const angle = getAngleFromEvent(event);
            updateSteeringWheel(angle);
            moveCar(angle);
        }
    }

    function handleSteeringEnd() {
        if (isDragging) {
            isDragging = false;
            // Langsam zur√ºck zur Mitte drehen
            let intervalId = setInterval(() => {
                currentAngle *= 0.8; // Faktor f√ºr R√ºckstellgeschwindigkeit
                updateSteeringWheel(currentAngle);
                moveCar(currentAngle);
                if (Math.abs(currentAngle) < 1) {
                    currentAngle = 0;
                    updateSteeringWheel(currentAngle);
                    moveCar(currentAngle);
                    clearInterval(intervalId);
                }
            }, 20); // Intervall f√ºr sanftes Zur√ºckdrehen
            steeringWheelContainer.style.cursor = 'pointer';
        }
    }

    // Event-Listener f√ºr das Lenkrad (Maus und Touch)
    steeringWheelContainer.addEventListener('mousedown', handleSteeringStart);
    steeringWheelContainer.addEventListener('touchstart', handleSteeringStart, { passive: false }); // passive: false wegen preventDefault

    document.addEventListener('mousemove', handleSteeringMove); // Auf document lauschen, damit es auch au√üerhalb funktioniert
    document.addEventListener('touchmove', handleSteeringMove, { passive: false }); // passive: false wegen preventDefault

    document.addEventListener('mouseup', handleSteeringEnd);
    document.addEventListener('touchend', handleSteeringEnd);
    steeringWheelContainer.addEventListener('mouseleave', handleSteeringEnd); // Auch wenn Maus Container verl√§sst


    // --- Kollisionserkennung und Explosion ---

    function checkCollision() {
      const carRect = car.getBoundingClientRect();
      // W√§hle nur Hindernisse aus, die nicht bereits als getroffen markiert sind
      const obstacles = gameSvg.querySelectorAll('.obstacle:not(.hit)');

      obstacles.forEach(obstacle => {
        const obstacleRect = obstacle.getBoundingClientRect();

        // Einfache Rechteck-Kollisionspr√ºfung
        if (isColliding(carRect, obstacleRect)) {
          // Nur explodieren lassen, wenn nicht schon .hit (Doppelcheck, falls QuerySelector nicht schnell genug war)
          if (!obstacle.classList.contains('hit')) {
                obstacle.classList.add('hit');
                createExplosion(obstacle); // Explosion ausl√∂sen

                // Nach kurzer Zeit die .hit-Klasse wieder entfernen, damit es normal weiterf√§hrt
                setTimeout(() => {
                    // Nur entfernen, wenn das Element noch existiert
                    if(obstacle) {
                        obstacle.classList.remove('hit');
                    }
                }, 600); // Etwas l√§nger als die Explosionsanimation
            }
        }
      });
    }

    function isColliding(rect1, rect2) {
      // Pr√ºft auf √úberlappung der Rechtecke
      return !(rect1.right < rect2.left ||
               rect1.left > rect2.right ||
               rect1.bottom < rect2.top ||
               rect1.top > rect2.bottom);
    }

    // NEU: Funktion zum Erstellen der Explosion
    function createExplosion(obstacle) {
        const numFragments = 8; // Anzahl der Teile
        const explosionDuration = 600; // Dauer in ms (sollte CSS-Animation entsprechen)

        // Position relativ zum SVG-Container bekommen
        const obstacleRect = obstacle.getBoundingClientRect();
        const svgRect = gameSvg.getBoundingClientRect();
        const startX = obstacleRect.left + obstacleRect.width / 2 - svgRect.left;
        const startY = obstacleRect.top + obstacleRect.height / 2 - svgRect.top;

        // Farbe des Hindernisses VOR dem Treffer holen
        const color = window.getComputedStyle(obstacle).fill;

        for (let i = 0; i < numFragments; i++) {
            const fragment = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const fragmentSize = 3 + Math.random() * 4; // Zuf√§llige Gr√∂√üe der Teile

            fragment.setAttribute('cx', startX);
            fragment.setAttribute('cy', startY);
            fragment.setAttribute('r', fragmentSize);
            fragment.setAttribute('fill', color); // Gleiche Farbe wie Hindernis
            fragment.classList.add('fragment'); // Basis-Klasse

            // Zuf√§llige Richtung und Distanz f√ºr die Explosion berechnen
            const angle = Math.random() * Math.PI * 2;
            const distance = 40 + Math.random() * 60; // Wie weit die Teile fliegen
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;

            // CSS-Variablen f√ºr die Animation setzen
            fragment.style.setProperty('--tx', `${tx}px`);
            fragment.style.setProperty('--ty', `${ty}px`);

            gameSvg.appendChild(fragment);
            fragment.classList.add('fragment-exploding'); // Startet die CSS-Animation

            // Fragment nach der Animation entfernen
            setTimeout(() => {
                fragment.remove();
            }, explosionDuration);
        }
    }

    // Regelm√§√üig Kollisionen √ºberpr√ºfen
    setInterval(checkCollision, 50); // H√§ufiger pr√ºfen f√ºr bessere Reaktionszeit


    // --- Dunkelmodus ---
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      // Optional: Zustand im localStorage speichern f√ºr Persistenz
       if (document.body.classList.contains('dark-mode')) {
           localStorage.setItem('darkMode', 'enabled');
       } else {
           localStorage.setItem('darkMode', 'disabled');
       }
    });

    // Beim Laden der Seite pr√ºfen, ob Dunkelmodus aktiv war
    if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
    }

  </script>
</body>
</html>
