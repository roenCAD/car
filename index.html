<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Autospiel mit Mehreren Spuren und Guter Steuerung</title>
  <style>
    /* Breite der Stra√üe */
    :root {
        --road-width: 800px;
        /* Anzahl Spuren nur f√ºr Linien-Berechnung in CSS */
        --num-lines-visual: 5;
    }

    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        justify-content: center;
        background-color: #f0f0f0;
        margin: 0; /* Verhindert unerwartete R√§nder */
        transition: background-color 0.3s ease, color 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
    }

    #road {
      width: var(--road-width);
      height: 550px;
      background-color: #6c757d;
      position: relative;
      margin: 20px auto; /* Oben/Unten etwas Abstand */
      overflow: hidden;
      border: 2px solid #333;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
      transition: background-color 0.3s ease, border-color 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
    }

    /* Leitlinien (visuell, beeinflussen Steuerung nicht) */
    #road::before {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background-image:
            repeating-linear-gradient(white 0px, white 25px, transparent 25px, transparent 0px),
            repeating-linear-gradient(white 0px, white 25px, transparent 25px, transparent 50px),
            repeating-linear-gradient(white 0px, white 25px, transparent 25px, transparent 50px),
            repeating-linear-gradient(white 0px, white 25px, transparent 25px, transparent 0px);
        background-size: 4px 50px;
        background-repeat: repeat-y;
        background-position:
            /* Positioniert 4 Linien f√ºr 5 visuelle Spuren */
            calc(var(--road-width) / var(--num-lines-visual) * 1) 0,
            calc(var(--road-width) / var(--num-lines-visual) * 2) 0,
            calc(var(--road-width) / var(--num-lines-visual) * 3) 0,
            calc(var(--road-width) / var(--num-lines-visual) * 4) 0;
        z-index: 0;
        animation: moveLines 0.8s linear infinite;
        will-change: background-position;
        /* Animation startet standardm√§√üig pausiert */
        animation-play-state: paused;
        transition: background-image 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode Linien */
    }

    @keyframes moveLines {
      0% { background-position-y: 0px; }
      100% { background-position-y: 50px; }
    }

    #car {
      width: 50px;
      height: 80px;
      background: #dc3545;
      border-radius: 15px 15px 5px 5px;
      position: absolute;
      /* Startet sichtbar am unteren Rand */
      bottom: 300px; /* Angepasst f√ºr besseren Start */
      /* Startet genau in der Mitte (CSS sorgt f√ºr Initialposition) */
      left: calc(50% - 25px); /* 25px = halbe Autobbreite */
      /* --- Tr√§gere Steuerung --- */
      transition: left 0.6s ease-out, background-color 0.3s ease, box-shadow 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
      z-index: 10;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      position: relative; /* Beibehalten f√ºr Kind-Positionierung */
      will-change: left; /* Performance Hinweis */
    }

    /* --- Frontscheibe --- */
    .windscreen {
        position: absolute;
        top: 10px; /* Abstand von oben */
        left: 5px;  /* Einr√ºckung links */
        right: 5px; /* Einr√ºckung rechts */
        height: 25px; /* H√∂he der Scheibe */
        background-color: #5dade2; /* Helleres Blau */
        border-radius: 10px 10px 4px 4px; /* Oben runder, unten flacher */
        z-index: 11; /* √úber dem Autok√∂rper */
        box-shadow: inset 0 2px 3px rgba(0,0,0,0.15); /* Leichter Innenschatten */
        transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
    }

    .wheel {
        position: absolute;
        width: 14px; height: 20px;
        background-color: #212529;
        border-radius: 4px; z-index: 9; /* Unter dem Autok√∂rper */
        transition: background-color 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
    }
    /* Angepasste Radpositionen (Beispiel, ggf. anpassen) */
    .wheel-tl { top: 15px; left: -10px; } /* Vorderachse weiter oben */
    .wheel-tr { top: 15px; right: -10px; }/* Vorderachse weiter oben */
    .wheel-bl { bottom: 10px; left: -10px; }/* Hinterachse */
    .wheel-br { bottom: 10px; right: -10px; }/* Hinterachse */

    /* --- NEU: Scheinwerfer-Strahlen --- */
    .headlight-beam {
        position: absolute;
        width: 0;
        height: 0;
        /* Startet an der vorderen Kante des Autos (height = 80px) */
        bottom: 80px;
        /* Standardm√§√üig unsichtbar */
        display: none;
        z-index: 8; /* Unter Auto (10) und R√§dern (9), √ºber Stra√üe (0) */
        pointer-events: none; /* Keine Mausinteraktion */
        /* Trapezoid/Dreieck mit Border-Trick erzeugen */
        border-style: solid;
        /* Farbe: Gelb, leicht transparent. Nur der untere Border ist sichtbar */
        border-color: transparent transparent rgba(255, 255, 0, 0.4) transparent;
        /* Breite der Basis (links+rechts) und L√§nge (unten) */
        border-width: 0 15px 70px 15px; /* Strahl: 70px lang, 30px breit am Ende */
    }

    .headlight-beam-left {
        left: 5px; /* Leicht nach innen von der linken Kante */
         /* Optional: Leichte Drehung nach au√üen */
        /* transform: rotate(-3deg); */
        /* transform-origin: 0% 0%; */
    }

    .headlight-beam-right {
        right: 5px; /* Leicht nach innen von der rechten Kante */
         /* Optional: Leichte Drehung nach au√üen */
        /* transform: rotate(3deg); */
        /* transform-origin: 100% 0%; */
    }


    /* SVG f√ºr Hindernisse */
    #game-svg {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%; z-index: 1;
    }

    .obstacle {
      fill: #28a745;
      animation: obstacleAnimation 5s linear infinite;
      transform-origin: center center;
      will-change: transform;
      /* Animation startet standardm√§√üig pausiert */
      animation-play-state: paused;
      transition: fill 0.3s ease; /* Sanfter √úbergang f√ºr Dark Mode */
    }
    @keyframes obstacleAnimation {
      0% { transform: translateY(-150px); }
      100% { transform: translateY(calc(550px + 150px)); } /* Stra√üe H√∂he + Puffer */
    }
    .obstacle.o1 { animation-delay: 0s; }
    .obstacle.o2 { animation-delay: -1.5s; }
    .obstacle.o3 { animation-delay: -3s; }
    .obstacle.o4 { animation-delay: -0.5s; }
    .obstacle.o5 { animation-delay: -2.5s; }
    .obstacle.o6 { animation-delay: -4s; }

    /* --- Lenkrad etc. --- */
     #steering-wheel-container {
        position: relative; /* Wichtig f√ºr absolute Positionierung des Kind-SVG */
        width: 100%; /* Volle Breite f√ºr Interaktion */
        height: 200px; /* H√∂he reduziert */
        margin: 10px 0 0 0; /* Weniger Abstand oben */
        overflow: hidden;
        cursor: pointer;
        background: none;
        touch-action: none;
     }
     #steering-wheel-svg {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        /* Visuelle Gr√∂√üe reduziert, passt zur Container-H√∂he */
        width: 300px;
        height: 150px;
        display: block;
     }
     #steering-wheel-svg path { fill: none; stroke: black; stroke-width: 8; transition: stroke 0.3s ease; } /* D√ºnner, Transition */
     /* Angepasst an neue viewBox/Gr√∂√üe */
     #steering-wheel-svg .wheel-line {
         stroke: red;
         stroke-width: 4; /* D√ºnner */
         transform-origin: 150px 150px; /* Zentrum der viewBox */
         transition: transform 0.1s linear, stroke 0.3s ease; /* Transition */
     }

     #dark-mode-toggle { position: relative; width: 40px; height: 40px; background-color: #eee; border-radius: 50%; cursor: pointer; margin: 10px auto; z-index: 20; border: 2px solid #aaa; box-shadow: 0 2px 4px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; font-size: 20px; transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; }
     #dark-mode-toggle::before { content: '‚òÄÔ∏è'; }

    /* Start Button Styling - VERGR√ñSSERT */
    #start-button {
        padding: 15px 30px; /* Etwas kleiner als vorher */
        font-size: 20px; /* Etwas kleiner */
        cursor: pointer;
        background-color: #4CAF50; /* Gr√ºn */
        color: white;
        border: none;
        border-radius: 8px;
        margin: 10px auto 15px; /* Abst√§nde angepasst */
        display: block;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease; /* Sanfter √úbergang */
    }
    #start-button:hover {
        opacity: 0.9;
    }
    #start-button.running {
         background-color: #f44336; /* Rot f√ºr Stop */
    }


    /* Hit wird nicht mehr f√ºr Farb√§nderung genutzt */
    .fragment { pointer-events: none; will-change: transform, opacity; z-index: 5; }
    .fragment-exploding { animation: explode 0.6s ease-out forwards; }
    @keyframes explode { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx, 0), var(--ty, 0)) scale(0.3); opacity: 0; } }

    /* --- Dunkelmodus Stile --- */
    body.dark-mode { background-color: #1a1a1a; color: #e0e0e0; }
    body.dark-mode #road { background-color: #343a40; border: 2px solid #555; } /* Dunkleres Grau */
    body.dark-mode #road::before {
         background-image: /* Gleiche Anzahl Linien wie oben */
            repeating-linear-gradient(#bbb 0px, #bbb 25px, transparent 25px, transparent 0px),
            repeating-linear-gradient(#bbb 0px, #bbb 25px, transparent 25px, transparent 50px),
            repeating-linear-gradient(#bbb 0px, #bbb 25px, transparent 25px, transparent 50px),
            repeating-linear-gradient(#bbb 0px, #bbb 25px, transparent 25px, transparent 0px);
    }
    body.dark-mode .obstacle { fill: #1e7e34; } /* Dunkleres Gr√ºn */
    body.dark-mode #car { background-color: #a02020; box-shadow: 0 4px 8px rgba(255,255,255,0.15); } /* Dunkleres Rot, weniger Schatten */
    body.dark-mode .windscreen {
        background-color: #2980b9; /* Etwas dunkleres Blau f√ºr Dark Mode */
        box-shadow: inset 0 2px 3px rgba(255,255,255,0.05); /* Subtiler Schatten */
    }
    body.dark-mode .wheel { background-color: #111; }

    /* --- NEU: Scheinwerfer im Dunkelmodus aktivieren --- */
    body.dark-mode #car .headlight-beam {
        display: block; /* Macht die Strahlen sichtbar */
    }

    body.dark-mode #steering-wheel-container {
        background: none; /* Kein Hintergrund mehr n√∂tig */
    }
    /* Lenkrad-SVG im Dark Mode */
    body.dark-mode #steering-wheel-svg path { stroke: #888; }
    body.dark-mode #steering-wheel-svg .wheel-line { stroke: #e06c75; } /* Helleres Rot f√ºr Sichtbarkeit */

    body.dark-mode #dark-mode-toggle { background-color: #333; border: 2px solid #777; box-shadow: 0 2px 4px rgba(255,255,255,0.1); }
    body.dark-mode #dark-mode-toggle::before { content: 'üåô'; }
    body.dark-mode #start-button { background-color: #007000; color: #e0e0e0; box-shadow: 0 4px 8px rgba(255,255,255,0.1); } /* Dunkleres Gr√ºn */
    body.dark-mode #start-button.running { background-color: #b71c1c; } /* Dunkleres Rot f√ºr Dark Mode Stop */

  </style>
</head>
<body>
  <div id="road">
    <svg id="game-svg">
      <!-- Hindernisse -->
      <circle class="obstacle o1" cx="80"  cy="-50" r="30" />
      <circle class="obstacle o2" cx="400" cy="-150" r="35" />
      <circle class="obstacle o3" cx="720" cy="-80" r="28" />
      <circle class="obstacle o4" cx="240" cy="-250" r="40" />
      <circle class="obstacle o5" cx="560" cy="-350" r="30" />
      <circle class="obstacle o6" cx="80"  cy="-450" r="25" />
      <circle class="obstacle o1" cx="400" cy="-550" r="32" />
      <circle class="obstacle o2" cx="720" cy="-650" r="22" />
      <circle class="obstacle o3" cx="240" cy="-720" r="38" />
      <circle class="obstacle o4" cx="560" cy="-820" r="33" />
      <circle class="obstacle o5" cx="400" cy="-900" r="29" />
    </svg>
    <div id="car">
        <!-- Frontscheibe -->
        <div class="windscreen"></div>
        <!-- NEU: Scheinwerfer-Strahlen (initial unsichtbar) -->
        <div class="headlight-beam headlight-beam-left"></div>
        <div class="headlight-beam headlight-beam-right"></div>
        <!-- R√§der (Position leicht angepasst) -->
        <div class="wheel wheel-tl"></div>
        <div class="wheel wheel-tr"></div>
        <div class="wheel wheel-bl"></div>
        <div class="wheel wheel-br"></div>
    </div>
  </div>

  <!-- Container bleibt 100% breit, aber H√∂he reduziert -->
  <div id="steering-wheel-container">
     <!-- SVG angepasst f√ºr neue Containergr√∂√üe/ViewBox -->
     <svg id="steering-wheel-svg" viewBox="0 0 300 150"> <!-- ViewBox angepasst -->
      <!-- Pfad angepasst an neue ViewBox -->
      <path d="M 20 145 A 130 130 0 0 1 280 145" />
      <!-- Linien angepasst an neue ViewBox und transform-origin -->
      <g id="wheel-lines">
          <line class="wheel-line" x1="150" y1="150" x2="150" y2="50" />
          <line class="wheel-line" x1="150" y1="150" x2="70" y2="110" /> <!-- Positionen angepasst -->
          <line class="wheel-line" x1="150" y1="150" x2="230" y2="110" /> <!-- Positionen angepasst -->
      </g>
    </svg>
  </div>

  <div id="dark-mode-toggle"></div>
  <button id="start-button">ENGINE</button> <!-- Bleibt Start/Stop Toggle -->

  <script>
    const car = document.getElementById('car');
    const road = document.getElementById('road');
    const steeringWheelContainer = document.getElementById('steering-wheel-container');
    const wheelLines = document.getElementById('wheel-lines');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const gameSvg = document.getElementById('game-svg');
    const startButton = document.getElementById('start-button');

    // --- Spielzustand ---
    let isSteeringActive = false;
    let currentAngle = 0;
    let collisionCheckInterval = null;
    let animationRunning = false;
    let returnIntervalId = null;

    // --- Lenkrad-Logik ---
    function getAngleFromEvent(event) {
        if (event.touches) event.preventDefault();

        const rect = steeringWheelContainer.getBoundingClientRect();
        // Angepasst an neues Layout: Drehpunkt unten mittig im VISUELLEN Lenkrad-SVG
        // Wir nehmen aber weiterhin die Container-Mitte f√ºr die Berechnung
        const svgRect = steeringWheelContainer.querySelector('svg').getBoundingClientRect();
        const centerX = svgRect.left + svgRect.width / 2;
        const centerY = svgRect.top + svgRect.height; // Unten am sichtbaren SVG

        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;

        let angle = Math.atan2(clientY - centerY, clientX - centerX) * (180 / Math.PI) + 90;

        // Begrenzung beibehalten oder anpassen
        angle = Math.max(-60, Math.min(60, angle)); // Winkelbereich evtl. anpassen
        return angle;
    }

    function updateSteeringWheel(angle) {
        currentAngle = angle;
        // Dreht die Linien innerhalb des SVG. transform-origin ist im CSS gesetzt.
        wheelLines.style.transform = `rotate(${angle}deg)`;
    }

    // --- Auto Bewegung ---
    function moveCar(angle) {
        const roadWidth = road.offsetWidth;
        const carWidth = car.offsetWidth;
        // Max. Versatz, z.B. +/- 40% der verf√ºgbaren Breite
        const maxCarOffsetPercentage = 0.40; // Auto kann weiter an den Rand
        const maxCarOffset = (roadWidth - carWidth) * maxCarOffsetPercentage;
        const maxAngle = 60; // Entspricht der Begrenzung in getAngleFromEvent

        // Lineare Zuordnung: Winkel -> Versatz
        const carOffset = (angle / maxAngle) * maxCarOffset;

        const carLeft = (roadWidth / 2) - (carWidth / 2) + carOffset;

        const minLeft = 0;
        const maxLeft = roadWidth - carWidth;

        car.style.left = `${Math.max(minLeft, Math.min(maxLeft, carLeft))}px`;
    }

    // --- Lenkrad Events ---
    function handleSteeringStart(event) {
        if (!animationRunning) return;
        if (returnIntervalId) {
            clearInterval(returnIntervalId);
            returnIntervalId = null;
        }
        isSteeringActive = true;
        const angle = getAngleFromEvent(event);
        updateSteeringWheel(angle);
        moveCar(angle);
        steeringWheelContainer.style.cursor = 'grabbing';
     }

    function handleSteeringMove(event) {
        if (!isSteeringActive || !animationRunning) return;
        const angle = getAngleFromEvent(event);
        updateSteeringWheel(angle);
        moveCar(angle);
     }

    function handleSteeringEnd() {
        if (!isSteeringActive) return;
        isSteeringActive = false;
        steeringWheelContainer.style.cursor = 'pointer';

        if (!animationRunning) return;

        if (returnIntervalId) clearInterval(returnIntervalId);

        // Sanftere, langsamere R√ºckkehr
        returnIntervalId = setInterval(() => {
            currentAngle *= 0.88; // Reduzierte D√§mpfung -> langsameres Zur√ºckfedern
            updateSteeringWheel(currentAngle);
            moveCar(currentAngle);

            if (Math.abs(currentAngle) < 0.5) {
                currentAngle = 0;
                updateSteeringWheel(currentAngle);
                moveCar(currentAngle);
                clearInterval(returnIntervalId);
                returnIntervalId = null;
            }
        }, 25); // Etwas l√§ngeres Intervall
     }

    // Event Listener
    steeringWheelContainer.addEventListener('mousedown', handleSteeringStart);
    steeringWheelContainer.addEventListener('touchstart', handleSteeringStart, { passive: false });

    document.addEventListener('mousemove', handleSteeringMove);
    document.addEventListener('touchmove', handleSteeringMove, { passive: false });

    document.addEventListener('mouseup', handleSteeringEnd);
    document.addEventListener('touchend', handleSteeringEnd);

    document.addEventListener('mouseleave', () => {
        if (isSteeringActive) handleSteeringEnd();
    });

    // --- Kollisionserkennung & Explosion ---
    function checkCollision() {
        if (!animationRunning) return;

        const carRect = car.getBoundingClientRect();
        const obstacles = gameSvg.querySelectorAll('.obstacle');
        const roadRect = road.getBoundingClientRect();

        obstacles.forEach(obstacle => {
            const obstacleRect = obstacle.getBoundingClientRect();

            if (obstacleRect.bottom < roadRect.top - 50 || obstacleRect.top > roadRect.bottom + 50) {
               return;
            }

            if (isColliding(carRect, obstacleRect)) {
                createExplosion(obstacle);
                // stopGame(); // Spiel bei Kollision stoppen
            }
        });
    }

    function isColliding(rect1, rect2) {
        return !(
            rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom
        );
    }

    function createExplosion(obstacle) {
        const numFragments = 8;
        const explosionDuration = 600; // ms
        const obstacleRect = obstacle.getBoundingClientRect();
        const svgRect = gameSvg.getBoundingClientRect();

        const startX = obstacleRect.left + obstacleRect.width / 2 - svgRect.left;
        const startY = obstacleRect.top + obstacleRect.height / 2 - svgRect.top;
        const color = window.getComputedStyle(obstacle).fill;

        for (let i = 0; i < numFragments; i++) {
            const fragment = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const fragmentSize = 3 + Math.random() * 4;
            fragment.setAttribute('cx', startX);
            fragment.setAttribute('cy', startY);
            fragment.setAttribute('r', fragmentSize);
            fragment.setAttribute('fill', color);
            fragment.classList.add('fragment');

            const angle = Math.random() * Math.PI * 2; // Vollkreis
            const distance = 40 + Math.random() * 40; // Explosionsradius
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;

            fragment.style.setProperty('--tx', `${tx}px`);
            fragment.style.setProperty('--ty', `${ty}px`);

            gameSvg.appendChild(fragment);
            fragment.classList.add('fragment-exploding');

            setTimeout(() => fragment.remove(), explosionDuration);
        }
        // Hindernis unsichtbar machen und verz√∂gert zur√ºcksetzen/neu positionieren
        obstacle.style.visibility = 'hidden';
        obstacle.style.animationPlayState = 'paused'; // Animation anhalten

        setTimeout(() => {
             // Beispiel: Hindernis oben neu positionieren mit zuf√§lliger X-Position
             const roadWidth = road.offsetWidth;
             const newCx = Math.random() * (roadWidth - 60) + 30; // Zuf√§llige X-Pos innerhalb der Stra√üe
             obstacle.setAttribute('cx', newCx);
             obstacle.setAttribute('cy', -50 - Math.random() * 100); // Startet wieder oben
             obstacle.style.visibility = 'visible';
             // Animation wieder starten, wenn das Spiel noch l√§uft
             if (animationRunning) {
                 obstacle.style.animationPlayState = 'running';
             }
             // Wichtig: Animation neu starten, damit es von oben beginnt
             // Trick: Animation kurz entfernen und wieder hinzuf√ºgen
             const animationName = window.getComputedStyle(obstacle).animationName;
             if (animationName && animationName !== 'none') {
                 obstacle.style.animation = 'none';
                 obstacle.offsetHeight; // Reflow erzwingen
                 obstacle.style.animation = ''; // CSS-definierte Animation wieder anwenden
                 // Spielzustand ber√ºcksichtigen
                 obstacle.style.animationPlayState = animationRunning ? 'running' : 'paused';
             }

         }, explosionDuration + 50); // Nach der Explosion + kleiner Puffer


     }


    // --- Spielstart / Stopp / Animationen ---
    function controlAnimations(run) {
        const playState = run ? 'running' : 'paused';
        road.style.setProperty('animation-play-state', playState);
        gameSvg.querySelectorAll('.obstacle').forEach(o => {
            // Nur steuern, wenn nicht gerade versteckt (nach Kollision)
            if (o.style.visibility !== 'hidden') {
                 o.style.animationPlayState = playState;
            }
        });
        console.log(`Animations ${playState}`);
    }

    function startGame() {
        if (animationRunning) return;
        console.log("Starting game...");
        animationRunning = true;
        controlAnimations(true);

        if (!collisionCheckInterval) {
            collisionCheckInterval = setInterval(checkCollision, 50);
            console.log("Collision check started");
        }

        startButton.textContent = "STOP"; // Text √§ndern zu STOP
        startButton.classList.add('running');
    }

    function stopGame() {
        if (!animationRunning) return;
        console.log("Stopping game...");
        animationRunning = false;
        controlAnimations(false);

        if (collisionCheckInterval) {
            clearInterval(collisionCheckInterval);
            collisionCheckInterval = null;
            console.log("Collision check stopped");
        }

        if (returnIntervalId) {
            clearInterval(returnIntervalId);
            returnIntervalId = null;
        }

        // Sofortiges Reset
        currentAngle = 0;
        updateSteeringWheel(currentAngle);
        const originalTransition = car.style.transition;
        car.style.transition = 'none';
        moveCar(currentAngle);
        car.offsetHeight;
        car.style.transition = originalTransition;


        isSteeringActive = false;
        steeringWheelContainer.style.cursor = 'pointer';

        startButton.textContent = "ENGINE"; // Text zur√ºck zu ENGINE
        startButton.classList.remove('running');
    }

    // Event Listener f√ºr Start/Stop Button
    startButton.addEventListener('click', () => {
        if (animationRunning) {
            stopGame();
        } else {
            startGame();
        }
    });

    // Intersection Observer
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (!entry.isIntersecting && animationRunning) {
                 console.log("Road not visible, stopping game.");
                 stopGame();
            }
        });
    }, { threshold: 0.1 });

    observer.observe(road);

    // --- Dunkelmodus ---
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode') ? 'enabled' : 'disabled');
    });

    if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
    }

    // --- Initialisierung ---
    console.log("Game initialized. Press ENGINE Button to play.");
    // Startbutton Text initial setzen
    startButton.textContent = "ENGINE";

  </script>
</body>
</html>
